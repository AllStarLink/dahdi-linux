Avoid 64bit division, or where needed use kernel support functions
for it.

Needed on (at least) armhf and i386.

Index: dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-core.c
===================================================================
--- dahdi-linux-2.11.1.0.20170917~dfsg.orig/drivers/dahdi/xpp/xbus-core.c
+++ dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-core.c
@@ -34,6 +34,7 @@
 #include <linux/workqueue.h>
 #include <linux/device.h>
 #include <linux/delay.h>	/* for msleep() to debug */
+#include <asm/div64.h>
 #include "xpd.h"
 #include "xpp_dahdi.h"
 #include "xbus-core.h"
@@ -1764,11 +1765,13 @@ out:
 
 static void xbus_fill_proc_queue(struct seq_file *sfile, struct xframe_queue *q)
 {
+	u64 tmp = q->worst_lag_usec;
+	u64 tmp_us = do_div(tmp, 1000);
 	seq_printf(sfile,
 		"%-15s: counts %3d, %3d, %3d worst %3d, overflows %3d worst_lag %02lld.%lld ms\n",
 		q->name, q->steady_state_count, q->count, q->max_count,
-		q->worst_count, q->overflows, q->worst_lag_usec / 1000,
-		q->worst_lag_usec % 1000);
+		q->worst_count, q->overflows, tmp,
+		tmp_us);
 	xframe_queue_clearstats(q);
 }
 
Index: dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-pcm.c
===================================================================
--- dahdi-linux-2.11.1.0.20170917~dfsg.orig/drivers/dahdi/xpp/xbus-pcm.c
+++ dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-pcm.c
@@ -120,6 +120,7 @@ static int xpp_ticker_step(struct xpp_ti
 {
 	unsigned long flags;
 	s64 usec;
+	u64 tick_period;
 	bool cycled = 0;
 
 	spin_lock_irqsave(&ticker->lock, flags);
@@ -129,7 +130,9 @@ static int xpp_ticker_step(struct xpp_ti
 		usec = ktime_us_delta(ticker->last_sample,
 					ticker->first_sample);
 		ticker->first_sample = ticker->last_sample;
-		ticker->tick_period = usec / ticker->cycle;
+		tick_period = usec;
+		do_div(tick_period, ticker->cycle);
+		ticker->tick_period = tick_period;
 		cycled = 1;
 	}
 	ticker->count++;
@@ -495,9 +498,9 @@ static void send_drift(xbus_t *xbus, int
 		msg = "down";
 	msec_delta = ktime_ms_delta(now, xbus->pll_updated_at);
 	XBUS_DBG(SYNC, xbus,
-		 "%sDRIFT adjust %s (%d) (last update %lld seconds ago)\n",
+		 "%sDRIFT adjust %s (%d) (last update %lld msec ago)\n",
 		 (disable_pll_sync) ? "Fake " : "", msg, drift,
-		 msec_delta / MSEC_PER_SEC);
+		 msec_delta);
 	if (!disable_pll_sync)
 		CALL_PROTO(GLOBAL, SYNC_SOURCE, xbus, NULL, SYNC_MODE_PLL,
 			   drift);
Index: dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-sysfs.c
===================================================================
--- dahdi-linux-2.11.1.0.20170917~dfsg.orig/drivers/dahdi/xpp/xbus-sysfs.c
+++ dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xbus-sysfs.c
@@ -242,6 +242,7 @@ static DEVICE_ATTR_READER(driftinfo_show
 	int speed_range;
 	int uframes_inaccuracy;
 	int i;
+	u64 tmp;
 
 	xbus = dev_to_xbus(dev);
 	di = &xbus->drift;
@@ -249,7 +250,9 @@ static DEVICE_ATTR_READER(driftinfo_show
 	/*
 	 * Calculate lost ticks time
 	 */
-	seconds = ktime_ms_delta(now, di->last_lost_tick) / 1000;
+	tmp = ktime_ms_delta(now, di->last_lost_tick);
+	do_div(tmp, 1000);
+	seconds = tmp;
 	minutes = seconds / 60;
 	seconds = seconds % 60;
 	hours = minutes / 60;
Index: dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xframe_queue.c
===================================================================
--- dahdi-linux-2.11.1.0.20170917~dfsg.orig/drivers/dahdi/xpp/xframe_queue.c
+++ dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xframe_queue.c
@@ -42,8 +42,8 @@ static void __xframe_dump_queue(struct x
 		xpacket_t *pack = (xpacket_t *)&xframe->packets[0];
 		s64 usec = ktime_us_delta(now, xframe->kt_queued);
 
-		snprintf(prefix, ARRAY_SIZE(prefix), "  %3d> %5lld.%03lld msec",
-			 i++, usec / 1000, usec % 1000);
+		snprintf(prefix, ARRAY_SIZE(prefix), "  %3d> %lld us",
+			 i++, usec);
 		dump_packet(prefix, pack, 1);
 	}
 }
@@ -60,11 +60,10 @@ static bool __xframe_enqueue(struct xfra
 	if (q->count >= q->max_count) {
 		q->overflows++;
 		if ((overflow_cnt++ % 1000) < 5) {
-			NOTICE("Overflow of %-15s: counts %3d, %3d, %3d worst %3d, overflows %3d worst_lag %02lld.%lld ms\n",
+			NOTICE("Overflow of %-15s: counts %3d, %3d, %3d worst %3d, overflows %3d worst_lag %lld us\n",
 			     q->name, q->steady_state_count, q->count,
 			     q->max_count, q->worst_count, q->overflows,
-			     q->worst_lag_usec / 1000,
-			     q->worst_lag_usec % 1000);
+			     q->worst_lag_usec);
 			__xframe_dump_queue(q);
 		}
 		ret = 0;
Index: dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xpp_usb.c
===================================================================
--- dahdi-linux-2.11.1.0.20170917~dfsg.orig/drivers/dahdi/xpp/xpp_usb.c
+++ dahdi-linux-2.11.1.0.20170917~dfsg/drivers/dahdi/xpp/xpp_usb.c
@@ -30,6 +30,7 @@
 #include <asm/uaccess.h>
 #include <asm/atomic.h>
 #include <asm/timex.h>
+#include <asm/div64.h>
 #include <linux/proc_fs.h>
 #include <linux/usb.h>
 #include "xpd.h"
@@ -878,7 +879,7 @@ static void xpp_send_callback(USB_PASS_C
 	ktime_t now;
 	s64 usec;
 	int writes = atomic_read(&xusb->pending_writes);
-	int i;
+	u64 i;
 
 	if (!xbus) {
 		XUSB_ERR(xusb,
@@ -894,7 +895,8 @@ static void xpp_send_callback(USB_PASS_C
 		usec = 0; /* System clock jumped */
 	if (usec > xusb->max_tx_delay)
 		xusb->max_tx_delay = usec;
-	i = usec / USEC_BUCKET;
+	i = (u64)usec;
+	do_div(i, USEC_BUCKET);
 	if (i >= NUM_BUCKETS)
 		i = NUM_BUCKETS - 1;
 	xusb->usb_tx_delay[i]++;
